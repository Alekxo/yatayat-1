<html>
<head>
    <title> Kathmandu Public Transport </title>
<link rel="stylesheet" href="lib/leaflet/leaflet.css" />
<!--[if lte IE 8]>
    <link rel="stylesheet" href="lib/leaflet/leaflet.ie.css" />
<![endif]-->
<style>
body {
  margin:0;
}
#errorLog {
  position: absolute;
  top: 0;
  right: 0;
  width: 300px;
  background-color: black;
  color: #00ff00;
  height: 100%;
  overflow: auto;
}
#errorLog li:hover {
  background-color: #333;
  color: red;
  cursor: pointer;
}
</style>
<script src="lib/jquery-1.7.2.min.js"></script>
<script src="lib/underscore-min.js"></script>
<script src="lib/leaflet/leaflet.js"></script>
<script src="lib/kdtree/src/web/kdTree.js"></script>
<script src="yatayat.js"></script>
<script src="config.js"></script>
</head>
<body>
<div id="publicTransportMap" style="width: 100%; height: 100%">Loading ...</div>
<pre id="error"><b>ERROR LOG</b><ol id="errorLog"> </ol></pre>
<script type="text/javascript" language="javascript">
// initialize the map
var map = new L.Map('publicTransportMap');

//var ktmBB = "85.2885,27.6839,85.3368,27.7299";
var system;
$.ajax({ type: YY.GET_OR_POST, url: YY.API_URL,
         data: YY.QUERY_STRING,
         dataType: 'text',
         success: function(data) {
             system = YY.fromOSM(data);
	     var renderLayer = YY.error_render(system, map, document.getElementById('errorLog'));
         }});

if(YY.TILE_SOURCE) {
    var tiles = new L.TileLayer(YY.TILE_SOURCE, {
        attribution: YY.ATTRIBUTION,
        maxZoom: 18
    });

    // add the layer to the map, set the view to a given place and zoom
    map.addLayer(tiles);
}

map.setView(new L.LatLng(YY.LAT, YY.LNG), 13);

var SAME_STOP_DIST = Math.pow(0.001,2);

function nearbyDifferentStops(system) {
    stopClosest = {};

    system.routes.forEach(function(route) {
        route.stops.forEach(function(stop) {
            var stops = system.nearestStops([stop.lat, stop.lng], 2, SAME_STOP_DIST)
                .filter(function(s) { return s.id !== stop.id; });
            if(stops.length > 0 && stop.name && stops[0].name !== stop.name) {
                stopClosest[stop.id] = stops[0];
            }
        });
    })

    return stopClosest;
}

function unnamedStops(system) {
    unnamedStops = {};

    system.routes.forEach(function(route) {
        route.stops.forEach(function(stop) {
            if(!stop.name) {
                unnamedStops[stop.id] = true;
            }
        });
    });

    return unnamedStops;
}

function similarNames(system) {
    // thanks! http://thinkphp.ro/apps/js-hacks/String.levenshtein/String.levenshtein.html
    var levenshtein = function(stringa, stringb) {
        var cost = new Array(),
        str1 = stringa,
        str2 = stringb,
        n = str1.length,
        m = str2.length,
        i, j;
        var minimum = function(a,b,c) {
            var min = a;
            if(b < min) {
                min = b;
            }
            if(c < min) {
                min = c;
            }
            return min;
        }

        if(n == 0 || m == 0) {
            return;  
        } 

        for(var i=0;i<=n;i++) {
            cost[i] = new Array();
        }

        for(i=0;i<=n;i++) {
            cost[i][0] = i;
        }

        for(j=0;j<=m;j++) {
            cost[0][j] = j;
        }

        for(i=1;i<=n;i++) {
            var x = str1.charAt(i-1);
            for(j=1;j<=m;j++) {
                var y = str2.charAt(j-1);
                if(x == y) {
                    cost[i][j] = cost[i-1][j-1]; 
                } else {
                    cost[i][j] = 1 + minimum(cost[i-1][j-1], cost[i][j-1], cost[i-1][j]);
                } 
            }
        }
        return cost[n][m];  
    };

    var preprocess = function(str) {
        return str.toLowerCase().replace(' ', '');
    };

    similarNames = {};

    // n^2 algorithm that compares string-distance between every two pairs of stop
    system.routes.forEach(function(route) {
        route.stops.forEach(function(stop) {
            
            system.routes.forEach(function(route2) {
                route.stops.forEach(function(stop2) {

                    if(stop.name && stop2.name && levenshtein(stop.name, stop2.name) < 3) {
                        var physicalDistance = Math.pow(stop.lat-stop2.lat,2) + Math.pow(stop.lng-stop2.lng,2);
                        if(physicalDistance > SAME_STOP_DIST) {
                            // console.log(stop.name, stop2.name, physicalDistance);
                            similarNames[stop.id] = stop2;
                        }
                        else if(stop.id != stop2.id) {
                            //console.log(stop.name, stop2.name, 'nearby');
                        }
                    }
                    
                });
            });
        });
    });
    return similarNames;
}

var unconnectedSegments = function(system) {
    unconnected = {};
    system.routes.forEach(function(route) {
        var last_seg = null;
        route.segments.forEach(function(segment) {
            if(last_seg) {
                var s1f = segment.listOfLatLng[0];
                var s1r = segment.listOfLatLng[segment.listOfLatLng.length-1];
                var s2f = last_seg.listOfLatLng[0];
                var s2r = last_seg.listOfLatLng[last_seg.listOfLatLng.length-1];

                // Something is wrong in the order() call.
                // Let's just check all pairs of starts and ends.
                if(!(_.isEqual(s1f, s2f) || _.isEqual(s1f, s2r) || 
                     _.isEqual(s1r, s2f) || _.isEqual(s1r, s2r))) {
                    unconnected[last_seg.id] = segment;
                }
            }
            last_seg = segment;
        });
    });
    return unconnected;
};

YY.error_render = function(system, map, log) {
    // Check for four classes of errors

    // 1. Nearby stops (are they the same?)
    var nearby = nearbyDifferentStops(system);
    var nearbycol = 'yellow';

    // 2. Unnamed stop
    var unnamed = unnamedStops(system);
    var unnamedcol = 'black';

    // 3. Similarly-named stop (that are far away)
    var simnames = similarNames(system);
    var simnamescol = 'magenta';

    // 4. Unconnected segments
    var unconnected = unconnectedSegments(system);
    var unconnectedcol = 'red';

    var addLog = function(msg, latlng, marker) {
        var $msg = document.createElement('li');
        $msg.innerHTML = msg;

        var pop = function() { 
            var popup = new L.Popup();
            popup.setLatLng(latlng);
            popup.setContent(msg);
            map.openPopup(popup);
        };
        $msg.onclick = pop;
        marker.on('click', pop);
        log.appendChild($msg);
    }

    system.routes.forEach(function(route, r_idx) {
        route.segments.forEach(function(seg, s_idx) {
            var latlngs = seg.listOfLatLng.map(function(LL) {
                return new L.LatLng(LL[0], LL[1]);
            });
            var poly;
            if(seg.id in unconnected) {
                poly = new L.Polyline(latlngs, {color: unconnectedcol});
                var msg = "unconnected segment";
                addLog(msg, latlngs[Math.floor(latlngs.length / 2)], poly);
            }
            else {
                poly = new L.Polyline(latlngs, {color: 'green', opacity:0.3});
            }
            map.addLayer(poly);
        });

        route.stops.forEach(function(stop) {
            var marker;
            var ll = new L.LatLng(stop.lat, stop.lng);
            if(stop.id in nearby) {
                marker = new L.CircleMarker(ll,
                                            {color: nearbycol});
                var msg = stop.name + " is rather close to " + nearby[stop.id].name + " but they have different names";
                addLog(msg, ll, marker);
            }
            else if(stop.id in unnamed) {
                marker = new L.CircleMarker(ll,
                                            {color: unnamedcol});
                var msg = "unnamed stop";
                addLog(msg, ll, marker);
            }
            else if(stop.id in simnames) {
                marker = new L.CircleMarker(ll,
                                            {color: simnamescol});
                var msg = stop.name + " has a similar name to far-off stop " + simnames[stop.id].name;
                addLog(msg, ll, marker);
            }
            else {
                marker = new L.CircleMarker(ll,
                                            {color: 'green', opacity:0.2});
            }
            if(marker)
                map.addLayer(marker);
        });
    });

};

</script>
</body>
</html>
