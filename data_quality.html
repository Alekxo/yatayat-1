<html>
<head>
    <title> Kathmandu Public Transport </title>
<link rel="stylesheet" href="lib/leaflet/leaflet.css" />
<!--[if lte IE 8]>
    <link rel="stylesheet" href="lib/leaflet/leaflet.ie.css" />
<![endif]-->
<style>
body {
  margin:0;
}
#error {
  position: absolute;
  bottom: 0;
  right: 0;
  height: 200px;
  background-color: black;
  color: #00ff00;
  width: 100%;
  overflow: auto;
}
#errorLog li:hover {
  background-color: #111;
  color: red;
  cursor: pointer;
}
#routepicker {
  position: absolute;
  top: 0;
  right: 0;
}
</style>
<script src="lib/jquery-1.7.2.min.js"></script>
<script src="lib/underscore-min.js"></script>
<script src="lib/leaflet/leaflet.js"></script>
<script src="lib/wax.leaf.min.js"></script>
<script src="lib/kdtree/src/web/kdTree.js"></script>
<script src="yatayat.js"></script>
<script src="dataquality.js"></script>
<script src="config.js"></script>
</head>
<body>
<div id="publicTransportMap" style="width: 100%; height: 100%">Loading ...</div>
<pre id="error"><b>WARNINGS</b><ol id="errorLog"> </ol></pre>
<select id="routepicker"></select>
<script type="text/javascript" language="javascript">
// initialize the map
var map = new L.Map('publicTransportMap'),
renderLayer,
sys;

function routeToggler(system) {
    var $rp = $('#routepicker')
        .change(function() {
            if(renderLayer) {
                map.removeLayer(renderLayer);
            }
            console.log('YY.error_render(',sys, sys.routes[$rp[0].selectedIndex], document.getElementById('errorLog'));
            renderLayer = YY.error_render(sys, sys.routes[$rp[0].selectedIndex], document.getElementById('errorLog'));
            map.addLayer(renderLayer);
        });
    system.routes.forEach(function(route) {
        var $opt = $('<option>')
            .html(route.name)
            .appendTo($rp);
    });
}

$.ajax({ type: YY.GET_OR_POST, url: YY.API_URL,
         data: YY.QUERY_STRING,
         dataType: 'text',
         success: function(data) {
             sys = YY.fromOSM(data);
             routeToggler(sys);
	     renderLayer = YY.error_render(sys, sys.routes[0], document.getElementById('errorLog'));
             map.addLayer(renderLayer);
         }});

if(YY.TILE_SOURCE) {
        if (YY.WAX) {
            wax.tilejson(YY.TILE_SOURCE, function(tilejson) {
                map.addLayer(new wax.leaf.connector(tilejson));
            });
        } else {
            var tiles = new L.TileLayer(YY.TILE_SOURCE, {
                attribution: YY.ATTRIBUTION,
                maxZoom: 18
            });
            map.addLayer(tiles);
        }
}

map.setView(new L.LatLng(YY.LAT, YY.LNG), 13);

var SAME_STOP_DIST = Math.pow(0.0005,2);

YY.error_render = function(system, route, log) {
    var layer = new L.LayerGroup();
    log.innerHTML = "";

    // Check for four classes of errors

    // 1. Nearby stops (are they the same?)
    var nearby = DQ.nearbyDifferentStops(route, system);
    var nearbycol = 'yellow';

    // 2. Unnamed stop
    var unnamed = DQ.unnamedStops(route);
    var unnamedcol = 'black';

    // 3. Similarly-named stop (that are far away)
    var simnames = DQ.similarNames(route, system);
    var simnamescol = 'magenta';

    // 4.1 Routes without a start / terminus
    var noTerminus = DQ.noTerminus(route);

    // 4.2 Unconnected segments (show only if terminus found)
    var unconnected = DQ.unconnectedSegments(route);
    var unconnectedcol = 'red';

    // 5. Stops with the same name one after another
    // XXX: TODO


    var addLog = function(msg, latlng, marker) {
        var $msg = document.createElement('li');
        $msg.innerHTML = msg;

        var pop = function() { 
            var popup = new L.Popup();
            popup.setLatLng(latlng);
            popup.setContent(msg);
            map.openPopup(popup);
        };
        $msg.onclick = pop;
        marker.on('click', pop);
        log.appendChild($msg);
    }
    _.each(route.segments,function(seg, idx) {
        if(seg.id in unconnected) {
            var latlngs = seg.listOfLatLng.map(function(LL) { return new L.LatLng(LL[0], LL[1]); });
            var poly = new L.Polyline(latlngs, {color: unconnectedcol});
            if (noTerminus && !idx) {
                var msg = "no start-point (or terminus) defined";
                addLog(msg, latlngs[Math.floor(latlngs.length / 2)], poly);
            } else if (!noTerminus) {
                var msg = "unconnected segment";
                addLog(msg, latlngs[Math.floor(latlngs.length / 2)], poly);
            }
            layer.addLayer(poly);

            // var seg2 = unconnected[seg.id];
            // var ll2 = seg2.listOfLatLng.map(function(LL) {return new L.LatLng(LL[0], LL[1]);});
            // var poly2 = new L.Polyline(ll2, {color: 'black'});
            // layer.addLayer(poly2);
            // delete unconnectedcol[seg.id]; // don't draw twice;
        }
        else {
            var latlngs = seg.listOfLatLng.map(function(LL) { return new L.LatLng(LL[0], LL[1]); });
            var poly = new L.Polyline(latlngs, {color: 'green'});
            layer.addLayer(poly);
        }
    });

    route.stops.forEach(function(stop) {
        var marker;
        var ll = new L.LatLng(stop.lat, stop.lng);
        if(stop.id in nearby) {
            marker = new L.CircleMarker(ll,
                                        {color: nearbycol});
            var routename = "";
            for(var rid in nearby[stop.id].routeDict) {
                routename = nearby[stop.id].routeDict[rid].name;
            }
            var msg = stop.name + " is rather close to " + nearby[stop.id].name + " (in route: "+ routename + ") but they have different names";
            addLog(msg, ll, marker);
        }
        else if(stop.id in unnamed) {
            marker = new L.CircleMarker(ll,
                                        {color: unnamedcol});
            var msg = "unnamed stop";
            addLog(msg, ll, marker);
        }
        else if(stop.id in simnames) {
            marker = new L.CircleMarker(ll,
                                        {color: simnamescol});
            var routename = "";
            for(var rid in simnames[stop.id].routeDict) {
                routename = simnames[stop.id].routeDict[rid].name;
            }
            var msg = stop.name + " has a similar name to far-off stop " + simnames[stop.id].name + ' (in route: ' + routename + ")";
            addLog(msg, ll, marker);
        }
        else {
            marker = new L.CircleMarker(ll,
                                        {color: 'green', opacity:0.2});
        }
        if(marker)
            layer.addLayer(marker);
    });

    return layer;
};

</script>
</body>
</html>
